" snipet
" <TAB>: completion.
" inoremap <expr><TAB>  pumvisible() ? "\<C-n>" : "\<TAB>"
inoremap <expr><S-TAB>  pumvisible() ? "\<C-p>" : "\<S-TAB>"

" Plugin key-mappings.
imap <C-k>     <Plug>(neosnippet_expand_or_jump)
smap <C-k>     <Plug>(neosnippet_expand_or_jump)

" SuperTab like snippets behavior.
" imap <expr><TAB> neosnippet#jumpable() ? "\<Plug>(neosnippet_expand_or_jump)" : pumvisible() ? "\<C-n>" : "\<TAB>"
imap <expr><TAB> pumvisible() ? "\<C-n>" : neosnippet#jumpable() ? "\<Plug>(neosnippet_expand_or_jump)" : "\<TAB>"
smap <expr><TAB> neosnippet#jumpable() ? "\<Plug>(neosnippet_expand_or_jump)" : "\<TAB>"

" For snippet_complete marker.
if has('conceal')
  set conceallevel=2 concealcursor=i
endif

" unite
let g:unite_enable_start_insert=1
let g:unite_source_history_yank_enable =1
let g:unite_source_file_mru_limit = 200
nnoremap <silent> ,uy :<C-u>Unite history/yank<CR>
nnoremap <silent> ,ub :<C-u>Unite buffer<CR>
nnoremap <silent> ,uf :<C-u>UniteWithBufferDir -buffer-name=files file<CR>
"  nnoremap <silent> ,ur :<C-u>Unite -buffer-name=register register<CR>
nnoremap <silent> ,uu :<C-u>Unite file_mru buffer<CR>

" Wand box
nmap <Leader>wb :Wandbox<CR>
nmap <leader>wo :WandboxOpenBrowser<CR>


" VimShell
nmap <Leader>sh :VimShell<CR>

" vim-clang
let g:clang_c_options = '-std=gnu11'
let g:clang_c_completeopt = 'menuone'
let g:clang_cpp_options = '-std=c++14 -stdlib=libc++ --pedantic-errors'
let g:clang_cpp_completeopt = 'menuone'
let g:clang_use_path = 1
let g:clang_auto = 1


" lisp
let g:slimv_swank_cmd = '! xterm -e sbcl --load ~/.vim/bundle/slimv/slime/start-swank.lisp &'
let g:slimv_repl_split = 'REPL'
let g:slimv_repl_simple_eval = 0
let g:slimv_lisp = '/usr/bin/sbcl'
let g:slimv_impl = 'sbcl'
let g:slimv_preferred = 'sbcl'

let g:list_rainbow = 1

" togle comment
nmap <Leader><Space> <Plug>(caw:i:toggle)
vmap <Leader><Space> <Plug>(caw:i:toggle)

" memo
map <Leader>mn  :MemoNew<CR>
map <Leader>ml  :MemoList<CR>
map <Leader>mg  :MemoGrep<CR>


" haskell
let g:haskell_conceal = 0
let g:haskell_conceal_wide = 1


let g:haskellmode_completion_ghc = 0
autocmd FileType haskell setlocal omnifunc=necoghc#omnifunc

" quck run
let g:quickrun_config = get(g:, 'quickrun_config', {})
let g:quickrun_config._ = {
      \ 'runner'    : 'vimproc',
      \ 'runner/vimproc/updatetime' : 60,
      \ 'outputter' : 'error',
      \ 'outputter/error/success' : 'buffer',
      \ 'outputter/error/error'   : 'quickfix',
      \ 'outputter/buffer/split'  : ':rightbelow 8sp',
      \ 'outputter/buffer/close_on_empty' : 1,
      \ }
let g:quickrun_config = {
      \   "_" : {
      \       "outputter/buffer/split" : ":botright",
      \       "outputter/buffer/close_on_empty" : 1
      \   },
      \}

let g:quickrun_no_default_key_mappings = 1
nnoremap \r :write<CR>:QuickRun -mode n<CR>        
xnoremap \r :<C-U>write<CR>gv:QuickRun -mode v<CR> 

" clang-format
let g:clang_format#style_options = {
      \ 'AccessModifierOffset' : -4,
      \ 'AllowShortIfStatementsOnASingleLine' : 'true',
      \ 'AlwaysBreakTemplateDeclarations' : 'true',
      \ 'Standard' : 'C++11',
      \ 'BreakBeforeBraces' : 'Stroustrup',
      \ }


" twitter
let twitvim_force_ssl = 1 
let twitvim_count = 40

let g:deoplete#enable_at_startup = 1
